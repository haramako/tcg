# coding: utf-8
# frozen_string_literal: true

# C#コード内のMarkerを検出する

require 'find'
require 'strscan'

class MarkDetector
  Marker = Struct.new(:tag, :text, :variant, :path, :line_no)

  attr_reader :word_list
  attr_reader :words
  attr_reader :marker_list
  attr_reader :found_unmarked

  EXCLUDE = %r{
             Cabinet.cs$|
             /Slua/|
             /Test/|
             /AutoGenerated/|
             /Editor/|
             /Vendor/|
             /NintendoSDKPlugin/|
             /EffectConverter\.cs
             }x

  def initialize(show_unmarked_str_ = false)
    @show_unmarked_str = show_unmarked_str_
    @word_list = []
    @words = Hash.new { |h, k| h[k] = 0 }
    @marker_list = []
    @found_unmarked = false
  end

  def find(root_path)
    Find.find(root_path) do |filename|
      begin
        next unless filename =~ /.+\.cs$/
        next if filename =~ EXCLUDE

        src = open(filename, 'r:utf-8', &:read)
        out = parse(src, filename)

        @marker_list.concat(out.select { |m| m.is_a? Marker })
      rescue
        puts "#{$!} in #{filename}"
        if $!
          puts $!.backtrace
        else
          puts "$ERROR_INFOが空です。"
        end
      end
    end
  end

  def replace(root_path, i18n)
    Find.find(root_path) do |filename|
      begin
        next unless filename =~ /.+\.cs$/
        next if filename =~ EXCLUDE

        src = open(filename, 'r:utf-8', &:read)
        out = parse(src, filename)

        out_src = out.map do |m|
          if m.is_a? Marker
            mes = i18n.find { |x| x.id == m.text && x.variant == (m.variant || '') }
            if mes
              if m.text != mes.text
                puts "変更をソースに反映しています '%s'(%s) => '%s'(%s)" % [m.text, m.variant, mes.text, mes.variant]
              end
              if mes.variant && mes.variant != ''
                puts '*************'
                "\"#{mes.text}\", \"#{mes.variant}\""
              else
                "\"#{mes.text}\""
              end
            elsif m.variant && m.variant != ''
              "\"#{m.text}\", \"#{m.variant}\""
            elsif m.text.is_a? String
              "\"#{m.text}\""
            else
              m.text
            end
          else
            m
          end
        end.join

        if src.size - out_src.size != 0
          puts "ファイルを書き換えました。ファイル=#{filename} ,サイズ= #{src.size} => #{out_src.size} (#{src.size - out_src.size})"
          open(filename, 'w:utf-8') { |f| f.write(out_src) }
        end
      rescue
        puts "#{$ERROR_INFO} in #{filename}"
        puts $ERROR_INFO.backtrace
      end
    end
  end

  def parse(src, path)
    @scanner = StringScanner.new(src, path)
    @out = []

    start_word = %r{ /\* | (\W)Marker\. | " | //\s+BEGIN-NO-TRANSLATE | // }x

    @errors = []
    # rubocop:disable Lint/AssignmentInCondition
    while str = @scanner.scan_until(start_word)
      # rubocop:enable Lint/AssignmentInCondition
      @out << str
      case @scanner.matched
      # rubocop:disable Lint/EmptyWhen
      when "\n"
      # なにもしない
      # rubocop:enable Lint/EmptyWhen
      when /BEGIN-NO-TRANSLATE/
        scan_until(/END-NO-TRANSLATE/)
      when '//'
        comment = scan_until(/\n/)
        @errors.pop if comment =~ /NO-TRANSLATE/
      when '"'
        scan(/([^"]*)"/)
        if @scanner[1].each_codepoint.any? { |c| c > 127 }
          @errors << "#{path}:#{line_no}: マークされていない日本語文字列があります, '#{@scanner[1]}'"
        end
      when '/*'
        scan_until(%r{\*/})
      when /Marker\./
        tag = scan(/\w+/)
        next if tag == 'RawText'
        scan(/\(/)
        params = []
        loop do
          scan(/\"([^"]*)\"|([^,^)]+)/, output: false)

          if @scanner[1]
            params << @scanner[1]
          elsif @scanner[2]
            params << @scanner[2].to_i
          else
            raise
          end

          break unless scan(/,/, output: false, allow_no_match: true)
        end
        @out << Marker.new(tag, params[0], params[1] || '', path, nil)
        # puts [tag, params].join(" ")
        scan(/\)/)
      else
        raise 'BUG ' + str
      end
    end

    @out << @scanner.rest

    puts @errors
    @out
  end

  def line_no
    @scanner.pre_match.count("\n") + 1
  end

  def scan_until(regex)
    m = @scanner.scan_until(regex)
    raise "#{regex} not found, rest = '#{@scanner.peek(50)}'" unless m
    @out << m
    m
  end

  def scan(regex, allow_space: true, output: true, allow_no_match: false)
    if allow_space
      space = @scanner.scan(/\s*/)
      @out << space if space && output
    end

    m = @scanner.scan(regex)
    unless allow_no_match
      raise "#{regex} not found, rest = '#{@scanner.peek(50)}'" unless m
    end
    @out << m if output && m

    # if allow_space
    #  space = @scanner.scan(/\s*/)
    #  @out << space if space && output
    # end

    m
  end
end

# 実行した時は、そのまま実行する
if $PROGRAM_NAME == __FILE__
  require 'optparse'

  op = OptionParser.new
  op.parse!

  if ARGV.empty?
    puts op.to_s
    exit
  end

  detector = MarkDetector.new(true)
  ARGV.each do |dir|
    detector.find(dir)
  end
  # detector.display

  if detector.found_unmarked
    puts "マークされていない日本語文字列を検出しました"
    exit(1)
  end
end
